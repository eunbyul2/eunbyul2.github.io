---
layout: post
title: "CKA 정리: Scheduler, Labels/Selectors, Taints & Tolerations"
date: 2026-01-10 19:00:00 +0900
categories: [Kubernetes, CKA]
tags: [kubernetes, scheduler, nodeName, labels, selectors, taints, tolerations, scheduling, cka]
published: true
---

## 1. 쿠버네티스 스케줄링이란?

쿠버네티스에서 **스케줄링(Scheduling)**이란 **새로 생성된 Pod를 어느 Node에 배치할지 결정하는 과정**
이 역할은 **kube-scheduler**가 담당

### kube-scheduler 동작 흐름(개념)
1. `spec.nodeName`이 비어 있는 Pod를 감시(스케줄링 후보)
2. 스케줄링 가능한 Node를 필터링(리소스/taint 등)
3. 점수 계산 및 최적 Node 선택
4. 바인딩(결과적으로 Pod의 `nodeName`이 채워짐)

## 2. Pod가 Pending 상태가 되는 대표 원인과 확인 루트

### 2-1) 스케줄링 자체가 안 되는 경우(노드 미할당)
특징:
- `kubectl get pod -o wide`에서 **NODE가 비어 있음**
- `kubectl describe pod`에서 `PodScheduled=False` 및 `FailedScheduling` 이벤트가 나올 수 있음

확인:
```bash
kubectl get pod <pod> -o wide
kubectl describe pod <pod>
kubectl get events --sort-by=.metadata.creationTimestamp | tail -n 30
```

### 2-2) 모든 노드가 조건을 만족하지 못하는 경우
예:
- taint를 toleration으로 허용하지 못함
- 리소스 부족
- nodeSelector / affinity 불일치

## 3. 수동 스케줄링: nodeName

`spec.nodeName`은 **특정 노드로 강제 배치**

```yaml
spec:
  nodeName: node01
```

핵심:
- 스케줄러를 **우회**하는 성격(시험/디버깅에서 자주 등장)
- Pod는 `nodeName`을 생성 후 수정하기 어렵기 때문에 필요 시 **삭제 후 재생성**이 기본 루트

## 4. Labels & Selectors

### 4-1) Label
오브젝트에 붙이는 **key=value 메타데이터**.  
예: `env=dev`, `tier=frontend`, `bu=finance`

### 4-2) Selector
Label 조건으로 오브젝트를 선택(필터링)하거나 연결하는 메커니즘.

조회:
```bash
kubectl get pods -l env=dev
kubectl get pods --selector env=dev
```

> `-l`과 `--selector`는 **완전히 동일**(단축/풀옵션 차이만)

AND 조건(콤마):
```bash
kubectl get pods -l env=dev,tier=frontend
```

### 4-3) `bu`는 무엇?
`bu`는 쿠버네티스 예약어가 아니라 **그냥 라벨 키 이름**이며, 관례적으로 Business Unit(사업부/부서)을 뜻할 때가 많다.  
쿠버네티스는 의미를 강제하지 않고, 우리는 `bu=finance` 같은 조건으로 선택만 함.

## 5. Labels/Selectors의 “연결” 사용처

### 5-1) ReplicaSet ↔ Pod 연결(초보 실수 포인트)
ReplicaSet YAML에는 label이 두 군데 나옴.

- `metadata.labels` : ReplicaSet **자기 자신의 라벨**
- `spec.template.metadata.labels` : ReplicaSet이 생성하는 **Pod의 라벨**
- `spec.selector.matchLabels` : ReplicaSet이 **관리할 Pod를 찾는 조건**

핵심 규칙:
- `spec.selector.matchLabels`는 **Pod 라벨(`spec.template.metadata.labels`)과 일치**해야 한다.

### 5-2) Service ↔ Pod 연결
Service는 selector로 **Pod 라벨**을 매칭하여 Endpoint를 만든다(ReplicaSet을 직접 보지 않음).

## 6. Annotations
- labels처럼 key/value 형태
- **선택(Selector) 용도가 아니라 기록용**
- 빌드 정보, 담당자, 연동 메타데이터 등 “정보성 데이터”에 사용

## 7. `kubectl get all`은 “진짜 all”이 아니다

```bash
kubectl get all
```

보통 Pod/Service/Deployment/RS/Job 등 일부만 표시
ConfigMap/Secret/Ingress/PVC/Role 등은 별도로 조회해야 함.

리소스 종류 확인:
```bash
kubectl api-resources
kubectl api-resources --namespaced=true
```

## 8. `kubectl replace --force`는 뭐냐?

```bash
kubectl replace --force -f nginx.yaml
```

의미:
- 기존 리소스를 **삭제 후 재생성**하는 동작과 동일
- Pod처럼 immutable 필드(nodeName 등) 변경이 필요할 때 “빠른 삭제+생성” 루트로 쓰이기도 함

주의:
- 재생성되므로 UID 변경, 순간 다운타임 가능
- 실무에서는 Deployment 등 상위 컨트롤러로 관리하는 게 정석

## 9. `kubectl get pods --watch`(= `-w`)

```bash
kubectl get pods -w
```

- 상태 변화를 실시간으로 관찰(Pending → ContainerCreating → Running 등)
- 디버깅 시 `describe`와 함께 사용


## 10. Taints & Tolerations

### 10-1) 핵심 정의
- **Taint(노드에 설정)**: “이 노드는 특정 조건을 만족하는 Pod만 받겠다”
- **Toleration(파드에 설정)**: “나는 그 taint를 허용(감내)할 수 있다”

> taint/toleration은 “Pod를 특정 노드로 보내는 기능”이 아니라  
> “노드가 특정 Pod만 받아주는 기능”이다.  
> 특정 노드로 **보내는** 강제는 보통 nodeSelector/nodeAffinity로 한다.

### 10-2) Taint effect 3종
- `NoSchedule`: 새 Pod를 해당 노드에 스케줄하지 않음
- `PreferNoSchedule`: 가능하면 피함(보장 X)
- `NoExecute`: 새 Pod 금지 + 기존 Pod도 toleration 없으면 퇴출(evict)

## 11. 실습 흐름: node01 taint 생성 → Pod Pending 분석 → toleration Pod 생성

### 11-1) node01에 taint 생성
문제:
> Create a taint on node01 with key=spray, value=mortein, effect=NoSchedule

정답:
```bash
kubectl taint nodes node01 spray=mortein:NoSchedule
```

확인:
```bash
kubectl describe node node01 | grep -i taint -A2
```

### 11-2) Pending 원인 분석 예시(실제 출력 형태)
`describe pod`의 Events에서:
- `0/2 nodes are available`
- `untolerated taint {node-role.kubernetes.io/control-plane: }`
- `untolerated taint {spray: mortein}`

해석:
- controlplane 노드: 기본 taint 때문에 거부
- node01: spray=mortein taint 때문에 거부
- Pod에 해당 toleration이 없어서 스케줄링 불가 → Pending

### 11-3) toleration이 있는 Pod(bee) 생성
문제:
> Create another pod named bee with nginx image, which has a toleration set to the taint mortein.

Pod YAML(정답 형태):
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: bee
spec:
  tolerations:
  - key: "spray"
    operator: "Equal"
    value: "mortein"
    effect: "NoSchedule"
  containers:
  - name: bee
    image: nginx
```

적용/검증:
```bash
kubectl apply -f bee.yaml
kubectl get pod bee -o wide
kubectl describe pod bee | grep -i toleration -A6
```

관찰(문제 문장):
> bee Pod가 toleration 덕분에 node01에 스케줄되었음을 확인하라

검증 방법:
- `kubectl get pod bee -o wide`에서 **NODE가 node01인지 확인**

## 12. controlplane의 NoSchedule taint 제거

문제:
> Remove the taint on controlplane, which currently has the taint effect of NoSchedule.

중요:
- **effect만 부분 제거는 불가**
- taint는 항상 **전체(key(:value):effect) 단위로 제거**

확인:
```bash
kubectl describe node controlplane | grep -i taint -A2
```

제거(대부분 환경):
```bash
kubectl taint nodes controlplane node-role.kubernetes.io/control-plane:NoSchedule-
```

환경에 따라 master 키일 수도 있음:
```bash
kubectl taint nodes controlplane node-role.kubernetes.io/master:NoSchedule-
```

## 13. 빠른 체크리스트(CKA 시험용)

- Pending이면:
  - `kubectl get pod -o wide` → NODE 비었나 확인
  - `kubectl describe pod <pod>` → Events에서 `FailedScheduling` 사유 확인
- selector:
  - `-l` == `--selector`
  - 콤마는 AND 조건
- taint:
  - 생성: `kubectl taint nodes <node> key=value:Effect`
  - 삭제: `kubectl taint nodes <node> key=value:Effect-` 또는 `key:Effect-`
- controlplane taint:
  - 기본적으로 NoSchedule이 걸려 있는 경우가 많음
- Pod의 immutable 변경:
  - delete + recreate 또는 `replace --force`
