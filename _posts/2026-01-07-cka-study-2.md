---
layout: post
title: "CKA 정리: Pod/Service 만들기(Imperative/Declarative), expose vs create service, selector/labels, kubectl explain, run --restart, run --expose 주의점"
date: 2026-01-07 18:00:00 +0900
categories: [Kubernetes, CKA]
tags: [kubectl, Service, Pod, expose, create-service, ClusterIP, selector, labels, endpoints, explain, run, restartPolicy, imperative, declarative, dns]
published: true
---
## 1. CKA에서 “Service 접근” 문제의 핵심: DNS 규칙

### 같은 namespace에서 Service 접근 DNS
- **같은 namespace**면 서비스 이름만으로 접근 가능  
  - 예: `db-service`
- 포트까지 포함하면:
  - `db-service:6379`

### FQDN(완전한 DNS)
- `db-service.marketing.svc.cluster.local:6379`
- 같은 namespace에서는 보통 **굳이 FQDN까지 안 씀** (써도 동작은 함)

## 2. `-n`, `--namespace`, `-n=...` 차이 (결론: 기능 차이 없음)

| 형태 | 예시 | 의미 |
|---|---|---|
| long option | `--namespace=research` | 가독성 좋음(문서/가이드) |
| short option | `-n research` | 현업/시험에서 가장 많이 씀 |
| short + equals | `-n=research` | 동작 동일하지만 잘 안 씀(비주류) |

> **결론:** 셋 다 동일 동작. 실전/CKA는 보통 `-n research`.

## 3. `expose`는 “Deployment를 만드는 명령”이 아니다

### expose의 정확한 역할
- `kubectl expose ...`는 **항상 Service를 생성**하는 명령
- 전제 조건: **노출할 대상 리소스(Pod/Deployment 등)가 이미 존재**해야 함

예시:

```bash
# (이미 존재하는) deployment nginx를 기준으로 Service 생성
kubectl expose deployment nginx --port=80 --type=ClusterIP
```

- ❌ expose가 Deployment까지 만들어주는 게 아님  
- ⭕ “기존 리소스를 기준으로 Service만 만들어줌”

## 4. `kubectl set image`에서 `set`은 “명령 그룹”이고, `set image`는 그 중 하나

### set의 의미
- `kubectl set <subcommand>` 형태
- 기존 리소스의 **특정 필드만 부분 수정**(명령형/imperative)

대표 예시:

```bash
kubectl set image deployment nginx nginx=nginx:1.17
kubectl set env deployment nginx ENV=prod
kubectl set resources deployment nginx --limits=cpu=500m,memory=512Mi
kubectl set serviceaccount deployment nginx sa-name
```

### set image의 효과(중요)
- Deployment의 `spec.template.spec.containers[].image`가 바뀜
- 결과적으로 **새 ReplicaSet 생성 + RollingUpdate 발생**

## 5. 명령형(Imperative) vs 선언형(Declarative)

### 명령형 (imperative)
- “지금 당장 이 행동을 해라”
- 예: `run`, `expose`, `set`, `scale`, `patch`

### 선언형 (declarative)
- “이 상태가 정답이니 맞춰라”
- 예: `kubectl apply -f xxx.yaml`

| 구분 | 명령형 | 선언형 |
|---|---|---|
| 관점 | 행동 지시 | 상태 선언 |
| 대표 | `kubectl set`, `kubectl expose` | `kubectl apply -f` |
| 장점 | 빠름(시험) | 재현성/운영/GitOps |
| 단점 | 기록/재현 어려움 | 파일 관리 필요 |

## 6. “로컬 YAML 파일” vs “클러스터 정본(etcd)” 차이

### 로컬 YAML
- 내가 원하는 상태(desired state)를 적어둔 설계도
- `apply/create` 전엔 아무 일도 안 일어남

### 클러스터(etcd)
- 쿠버네티스가 관리하는 진짜 정본(source of truth)
- 컨트롤러/스케줄러/쿠블릿이 이 상태를 기준으로 동작

> 명령형(`set image` 등)은 로컬 파일을 바꾸지 않고 **클러스터 상태만 즉시 변경**함.

## 7. `spec` vs `status` (중요: `status`는 작성 대상이 아님)

| 영역 | 의미 | 누가 채움 |
|---|---|---|
| `spec` | 원하는 상태 | 사용자 |
| `status` | 실제 상태/결과 | 쿠버네티스(내부 컴포넌트) |

예:

```yaml
status:
  conditions:
  - type: Initialized
    status: "True"
```

- `status`는 관찰/디버깅용 결과
- YAML에 `status`를 써서 `apply`해도 **반영되지 않음/무시됨**

## 8. `kubectl explain` 사용법: “YAML 필드 사전”

### 목적
- 리소스 YAML의 필드 구조/타입/설명을 CLI에서 확인

### 자주 쓰는 패턴

```bash
kubectl explain pod
kubectl explain pod.spec
kubectl explain pod.spec.containers
kubectl explain deploy.spec.template.spec.containers
kubectl explain service.spec.ports --recursive
```

### 차이
- `kubectl explain pods` : 최상위 구조(목차)
- `kubectl explain pods.spec` : `spec` 아래를 집중 확인
- `kubectl explain pods --recursive` : 트리 전체 펼침(너무 길어질 수 있음)

> 시험에서는 `--recursive`를 “전체 리소스”가 아니라 **필요한 필드에만** 붙이는 게 효율적.

## 9. `grep -A5` 의미
- `grep -A5 ports` = `ports` 매칭 줄 **이후 5줄 더 출력**
- YAML 일부를 빠르게 확인할 때 유용

```bash
kubectl get pod custom-nginx -o yaml | grep -A5 ports
```

## 10. `kubectl run`에서 `--restart=Never`가 왜 중요?

### 결론
- **Pod 문제는 Pod로 확정**하는 게 안전

그래서 CKA에선 보통:

```bash
kubectl run custom-nginx --image=nginx --restart=Never --port=8080
```

### 이유(핵심)
- `kubectl run`은 버전/환경에 따라 “Pod/Deployment/Job” 쪽으로 동작이 바뀐 역사(혼란)가 있음
- 채점은 “이름이 `custom-nginx`인 Pod”를 기대하는데,
  - Deployment가 생성되면 Pod 이름이 `custom-nginx-xxxxx`가 되어 오답 위험

> 안전 습관: **Pod 생성 문제면 `--restart=Never`로 Pod 확정.**

## 11. Service가 Pod를 “이름”으로 찾지 않는다: `labels/selector` & `endpoints`

### 핵심 1줄
- Service는 selector(label 조건)로 Pod를 찾는다. **Pod 이름은 안 본다.**

### 연결 구조

Pod:

```yaml
metadata:
  labels:
    app: httpd
```

Service:

```yaml
spec:
  selector:
    app: httpd
```

### 검증 포인트: Endpoints

```bash
kubectl get endpoints httpd
# IP가 떠야 정상(서비스가 Pod를 찾은 상태)
```

Endpoints가 `<none>`이면:
- selector가 없거나
- selector와 Pod labels가 매칭되지 않은 것

## 12. Service 만드는 3가지 방법 (CKA 관점 정리)

### 12-1) `kubectl expose` (기존 리소스 노출)
- 기존 Pod/Deployment 기준으로 Service 생성
- selector를 보통 자동으로 붙여주는 편이라 빠르고 안전한 경우가 많음

예:

```bash
kubectl expose pod redis --name=redis-service --port=6379 --type=ClusterIP
```

### 12-2) `kubectl create service` (Service 뼈대 생성)
- Service만 생성
- selector를 옵션으로 직접 지정하기 어려움 → 보통 patch나 YAML 수정이 필요해질 수 있음
- 이 환경에서는 포트를 `--tcp=PORT:TARGETPORT`로 받음

예:

```bash
kubectl create service clusterip redis-service --tcp=6379:6379
# 필요 시 selector는 patch로 추가
kubectl patch svc redis-service -p '{"spec":{"selector":{"app":"redis"}}}'
```

#### 왜 `--port`가 아니라 `--tcp`?
- `create service <type>`는 포트 설정을 **프로토콜(TCP/UDP/SCTP) + port/targetPort 매핑**으로 받도록 설계되어 있음.

### 12-3) YAML 작성 후 `apply` (실무 표준)
- 운영/협업/GitOps는 이 방식이 표준
- 시험에서 “imperative만”을 강하게 요구하면 주의

## 13. `create service -o yaml`로 뽑아서 수정해도 된다

```bash
kubectl create service clusterip redis-service --tcp=6379:6379 \
  --dry-run=client -o yaml > svc.yaml

# svc.yaml에서 selector 등을 추가/수정
kubectl apply -f svc.yaml
```

- create로 뼈대 만들고 → YAML에서 구조를 완성하는 방식
- 이해/안정성 측면에서 매우 좋음

## 14. 문제 풀이 정리: `redis-service` (existing redis pod 노출)

문제:
- existing `redis` pod를 ClusterIP로 port 6379에 노출, imperative

### 가장 깔끔한 정답(의도에 가장 부합)

```bash
kubectl expose pod redis --name=redis-service --port=6379 --type=ClusterIP
kubectl get ep redis-service
```

### `create service`로도 가능하지만(추가 작업 가능성 큼)

```bash
kubectl create service clusterip redis-service --tcp=6379:6379

# endpoints가 비면 label/selector를 맞춰야 함
kubectl label pod redis app=redis
kubectl patch svc redis-service -p '{"spec":{"selector":{"app":"redis"}}}'

kubectl get ep redis-service
```

## 15. “Pod 만들고 + Service 만들기” 최소 스텝(안정 버전)

문제:
- `httpd` Pod(`httpd:alpine`) 생성 후,
- 같은 이름(`httpd`) ClusterIP 서비스 생성,
- `port/targetPort` 80

안정적인 2-step (CKA에서 실수 적음)

```bash
kubectl run httpd --image=httpd:alpine --restart=Never --labels=app=httpd
kubectl expose pod httpd --name=httpd --port=80 --target-port=80 --type=ClusterIP
kubectl get ep httpd
```

## 16. `kubectl run ... --expose`로 “Pod+Service 한 줄”이 되나?

### 결론
- 될 수도 있고, 안 될 수도 있음(버전 의존)
- CKA 관점에서는 “한 줄 편의 기능”이라 메인 풀이로는 위험

### 원리(지원되는 환경이라면)
내부적으로:
- `run`으로 Pod 생성
- 이어서 `expose`처럼 Service 생성

즉, 쿠버네티스 개념상 “한 리소스로 두 개를 생성”하는 게 아니라  
**kubectl이 두 리소스를 연속으로 만들어주는 것**

### 안전한 판단
- 시험에서는 “재현 가능한 2-step(run + expose)”를 기본으로 가져가는 편이 안전

## 마무리 체크리스트 (Service 문제에서 항상 확인)

```bash
kubectl get svc <name>               # 서비스 생성됐나?
kubectl get ep <name>                # Endpoints가 붙었나? (가장 중요)
kubectl get pod <pod> --show-labels  # 라벨은 뭐가 붙어있나?
kubectl get svc <name> -o yaml       # selector가 무엇인가?
```