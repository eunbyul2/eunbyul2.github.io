---
layout: post
title: "CKA 공부: reate vs apply, run/expose, Service/Endpoint, ReplicaSet apiVersion/selector/ImagePullBackOff까지"
date: 2026-01-06 18:00:00 +0900
categories: [Kubernetes, CKA]
tags: [kubectl, apply, create, run, expose, Service, Endpoint, ReplicaSet, apiVersion, selector, labels, jsonpath, NodePort]
published: true
---

- kubectl create -f vs kubectl apply -f 차이
- kubectl run, kubectl expose의 역할 정리
- Service에서 port/targetPort/nodePort 구분 및 확인 방법 정리
- kubernetes 시스템 Service의 targetPort, labels, endpoints 확인 루트
- ReplicaSet에서 apiVersion, selector ↔ template.labels 규칙 및 대표 에러 정리
- ImagePullBackOff 원인 파악 및 해결 루트 정리
- -o, --dry-run, > 리다이렉션, jsonpath, 파이프(|) 문법 정리
- Pod 삭제를 label selector로 한 번에 처리하는 법

# 1. kubectl create -f vs kubectl apply -f 차이
## 1) kubectl create -f
- 리소스를 “새로 생성”하는 명령
- 이미 같은 이름의 리소스가 있으면 에러가 나는 방식
- 선언형 파일을 최초 1회 생성할 때 자주 사용함

```bash
kubectl create -f nginx-deployment.yaml
```

## 2) kubectl apply -f
- 리소스를 “생성 또는 업데이트”하는 명령
- 같은 이름이 이미 있으면 변경사항을 반영하는 방식
- 선언형 운영(GitOps 포함)에서 표준임

```bash
kubectl apply -f nginx-deployment.yaml
```

## 3) apply 경고: last-applied-configuration
- apply 시 해당 경고가 뜰 수 있음.
- 리소스가 예전에 create로 생성되었고, kubectl apply가 관리에 필요한 annotation이 없을 때 뜨는 경고
- 치명적 에러가 아니라 “apply로 관리하려면 저장된 선언 상태가 필요함”이라는 안내
- kubectl apply가 자동으로 annotation을 패치할 수 있음
- 앞으로는 처음부터 apply로 만들거나, create --save-config로 만들면 깔끔해짐

# 2. kubectl run
## 1) kubectl run의 역할
- 단일 Pod를 빠르게 만들거나, YAML 템플릿 생성에 쓰는 명령
- 쿠버네티스 버전에 따라 동작 옵션이 제한될 수 있음
- “Deployment 생성”은 기본 목적이 아님(버전/옵션에 따라 다름)

```bash
kubectl run nginx --image=nginx
```

## 2) run으로 만든 Pod는 껐다 켜면 사라짐?
- 클러스터는 “노드 재부팅” 같은 이벤트로 Pod가 날아갈 수 있음
- Pod만 단독으로 만들면 컨트롤러(Deployment/ReplicaSet)가 재생성을 보장하지 않음
- 재생성/롤링업데이트/복구를 원하면 Deployment 같은 컨트롤러가 필요함

- “실습/테스트”는 run으로 빠르게 함
- “운영/복구 보장”은 Deployment/ReplicaSet을 씀

# 3. --dry-run, -o, > 문법 정리
## 1) --dry-run=client
- 실제로 클러스터에 생성/변경하지 않고 “만들어질 오브젝트”만 미리 출력하는 옵션임

```bash
kubectl run nginx --image=nginx --dry-run=client -o yaml
```

## 2) -o
- 출력 포맷 옵션으로 자주 쓰는 값은 yaml, json, wide, name, jsonpath=...

```bash
kubectl get pod nginx -o yaml
kubectl get svc -o wide
```

## 3) > 리다이렉션
터미널 출력 결과를 파일로 저장하는 쉘 기능(kubectl 기능 아님)

```bash
kubectl run nginx --image=nginx --dry-run=client -o yaml > nginx-pod.yaml
```

# 4. kubectl create replicaset에서 --image가 안 먹는 이유

```bash
kubectl create replicaset busybox-pod --image=busybox --dry-run=client
error: unknown flag: --image
```

### 원인
kubectl create replicaset 서브커맨드는 --image 플래그를 지원하지 않는 형태(일부 create 하위 명령만 지원함)

### 대안 패턴
- kubectl run으로 템플릿 생성 후 kind를 바꾸는 방식 사용
- 또는 공식적으로 지원되는 kubectl create deployment --image=... 패턴을 활용

# 5. ReplicaSet 핵심 규칙: selector와 template.labels 일치
ReplicaSet은 아래 규칙이 핵심

## 1) 반드시 같아야 하는 값
- spec.selector.matchLabels
- spec.template.metadata.labels

이 둘이 불일치하면 ReplicaSet이 “내가 관리할 Pod”를 제대로 인식 못 하게 됨.

selector는 “내가 관리할 Pod를 고르는 조건”
template.labels는 “내가 만들 Pod에 붙일 라벨”  
둘이 같아야 “내가 만든 Pod를 내가 다시 잡을 수 있음”

## 2) metadata.name
- 리소스의 이름
- ReplicaSet 자체의 이름
- selector/app name과 같아야 한다는 규칙은 없음
- 실무에서는 가독성을 위해 비슷하게 맞추는 편

## 3) metadata 아래 name은 항상 있어야 함?
- 대부분의 리소스는 metadata.name이 필요
- 이름을 기반으로 조회/수정/삭제가 이뤄짐
- generateName 같은 예외적 방식도 있으나 시험/일반 운영에서는 name을 씀

# 6. labels에서 app/tier/name 차이
labels의 key(app, tier, name)는 의미가 정해진 예약어가 아닌 라벨 키

- app: 애플리케이션 이름 구분용
- tier: frontend/backend 같은 계층 구분용
- name: 단순 식별용으로 쓰기도 함

### 중요한 원칙
- Service selector / ReplicaSet selector가 어떤 키를 쓰든 상관없음
- 중요한 건 **“selector가 Pod labels와 정확히 일치”**하는지 여부임

# 7. ImagePullBackOff 원인과 해결 루트
## 1) 현상
Pod 상태가 ImagePullBackOff 또는 ErrImagePull로 뜸

## 2) 가장 흔한 원인
이미지 이름 오타 또는 존재하지 않는 태그임

## 3) 확인 루트
```bash
kubectl describe pod <pod-name>
```
Events에 “Pulling image … / Failed …”가 뜸.
이미지 이름이 문제인지 바로 확인 가능

## 4) 수정 루트임
- ReplicaSet/Deployment의 spec.template.spec.containers[].image를 올바른 이미지로 수정
- 이미 생성된 Pod들은 기존 이미지로 떠 있으므로 삭제 후 재생성 유도함
- **컨트롤러 수정 → Pod 삭제 → 컨트롤러가 새 Pod를 올바른 이미지로 생성함**

# 8. Pod 여러 개를 한 번에 삭제하는 법
- Pod 이름 뒤에 붙는 -7xjz4 같은 문자열은 랜덤 suffix임.
- 이걸 일일이 찍어서 지우면 비효율임.

## 1) label selector로 삭제
```bash
kubectl delete pod -l app=new-replica-set
```

## 2) label 확인 방법
```bash
kubectl get pods --show-labels
```

## 3) 전부 삭제는 --all
```bash
kubectl delete pod --all
```

# 9. “ReplicaSet 두 개 삭제” 문제에서 자주 하는 실수
### 문제 예시
Delete the two newly created ReplicaSets - replicaset-1 and replicaset-2

### 실수 패턴
> kubectl delete pod replicaset-1 replicaset-2로 Pod 삭제를 시도함
그런데 replicaset-1은 Pod 이름이 아니라 ReplicaSet 이름임
그래서 NotFound가 뜨는 구조임

### 정답 루트
```bash
kubectl delete rs replicaset-1 replicaset-2
```
또는

```bash
kubectl delete replicaset replicaset-1 replicaset-2
```

# 10. Deployment describe로 오류 원인 찾기
kubectl describe deploy ...에서 가장 중요한 영역은 아래임.

```
Replicas: ... | ... available | ... unavailable

Containers: Image: ...

Events: 섹션
```

특히 Events가 “뭐가 실제로 일어났는지”를 보여주는 1순위 근거

# 11. apiVersion은 고정?
- 임의로 쓰는 값이 아님
- 쿠버네티스 버전이 올라가며 deprecated/removed가 발생할 수 있음
- 다만 핵심 리소스(Pod/Service/Deployment/ReplicaSet)는 안정화되어 오랫동안 유지되는 편

### 가장 안전한 확인 방법은 클러스터에 직접 물어보는 방식

```bash
kubectl api-resources
```
이 출력이 “이 클러스터에서 유효한 apiVersion”의 정답

# 12. Service의 port/targetPort/nodePort, 그리고 kubernetes Service 문제
## 1) kubectl get svc에서 보이는 포트는 무엇인가?
- PORT(S) 컬럼은 Service의 spec.ports[].port만 보여줌.
- targetPort는 요약 출력에 안 나옴.

## 2) “kubernetes service의 targetPort는 무엇인가?” 문제 풀이법
- 요약 출력으로는 알 수 없으므로 반드시 YAML에서 확인

```bash
코드 복사
kubectl get svc kubernetes -o yaml
```

또는 targetPort만 뽑는 방식

```bash
코드 복사
kubectl get svc kubernetes -o jsonpath='{.spec.ports[0].targetPort}{"\n"}'
```

- 선택지에서 흔히 나오는 정답 후보는 6443임.
- 443은 Service port임.
- 10.43.0.1 같은 값은 ClusterIP임.

## 3) “kubernetes service에 labels가 몇 개인가?” 문제 풀이법
- labels는 metadata.labels에 있음.
- YAML로 직접 확인하거나 jsonpath로 확인

```bash
kubectl get svc kubernetes -o jsonpath='{.metadata.labels.*}' | wc -w
```

> -o jsonpath=...는 원하는 필드만 출력함
{.metadata.labels.*}는 labels map의 “모든 value”를 나열함
|는 앞 출력 결과를 뒤 명령 입력으로 넘기는 파이프임
wc -w는 공백 기준 단어 개수를 세는 명령임
결과가 labels 개수에 해당함

# 13. Endpoint란 무엇임. 어떻게 확인함
## 1) Endpoint 정의임
- Endpoint는 “Service가 실제로 트래픽을 전달하는 대상(IP:Port) 목록”임.
- Service는 논리적인 입구이고 Endpoint가 실제 목적지

## 2) Endpoint 확인 명령
```bash
kubectl get endpoints
kubectl get ep
kubectl get endpoints <service-name>
kubectl describe endpoints <service-name>
```

## 3) Endpoint가 비어 있는 경우
- selector가 없거나
- selector와 Pod label이 안 맞거나
- Pod가 Ready가 아니거나
- Pod 자체가 없다는 의미임

**Service 트러블슈팅은 Endpoint부터 보는 습관이 효율적**

# 14. yaml 템플릿 순서 혼란 정리
- YAML의 필드 순서는 정답에 영향을 주지 않음
- Kubernetes는 “키 이름”으로 해석함
- 템플릿 순서는 단지 뼈대이므로, 문제에서 요구한 값만 정확하면 정답임.

```yaml
코드 복사
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
  namespace: default
spec:
  type: NodePort
  selector:
    name: simple-webapp
  ports:
  - port: 8080
    targetPort: 8080
    nodePort: 30080
```

# 15. kubectl expose 란?
- 이미 존재하는 Pod/Deployment 등을 “Service로 노출”시키는 명령
- Service를 자동 생성함
- selector를 자동으로 맞춰주는 장점이 있음

```bash
코드 복사
kubectl expose deployment web --port=80
kubectl expose deployment web --type=NodePort --port=8080
```

> nodePort를 문제에서 특정 값으로 요구하면 YAML이 더 확실함
여러 포트/복잡한 설정은 YAML이 필요함

# 16. 실습에서 반복된 핵심 체크리스트
## 1) 리소스 생성이 안 될 때
- apiVersion/kind 오타 여부 확인
- kubectl api-resources로 지원 버전 확인

## 2) Service 접속이 안 될 때
- selector와 Pod labels 일치 확인
- endpoints가 비어 있는지 확인

## 3) Pod가 Running이 안 될 때
- kubectl describe pod Events 확인이 1순위
- ImagePullBackOff면 이미지명/태그 오타부터 의심